// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: post.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const createPost = `-- name: CreatePost :one
INSERT INTO posts (
  author_id, title, abstract, cover_image, content
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, author_id, title, abstract, cover_image, content, status, is_featured, view_count, update_at, publish_at
`

type CreatePostParams struct {
	AuthorID   int64  `json:"author_id"`
	Title      string `json:"title"`
	Abstract   string `json:"abstract"`
	CoverImage string `json:"cover_image"`
	Content    string `json:"content"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, createPost,
		arg.AuthorID,
		arg.Title,
		arg.Abstract,
		arg.CoverImage,
		arg.Content,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.Title,
		&i.Abstract,
		&i.CoverImage,
		&i.Content,
		&i.Status,
		&i.IsFeatured,
		&i.ViewCount,
		&i.UpdateAt,
		&i.PublishAt,
	)
	return i, err
}

const createPostStar = `-- name: CreatePostStar :exec
INSERT INTO post_stars (post_id, user_id)
VALUES ($1, $2)
`

type CreatePostStarParams struct {
	PostID int64 `json:"post_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) CreatePostStar(ctx context.Context, arg CreatePostStarParams) error {
	_, err := q.db.Exec(ctx, createPostStar, arg.PostID, arg.UserID)
	return err
}

const deletePostStar = `-- name: DeletePostStar :exec
DELETE FROM post_stars
WHERE post_id = $1 AND user_id = $2
`

type DeletePostStarParams struct {
	PostID int64 `json:"post_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeletePostStar(ctx context.Context, arg DeletePostStarParams) error {
	_, err := q.db.Exec(ctx, deletePostStar, arg.PostID, arg.UserID)
	return err
}

const deletePosts = `-- name: DeletePosts :execrows
DELETE FROM posts
WHERE id = ANY($1::bigint[]) AND author_id = $2::bigint
  AND status = ANY('{draft, revise}'::varchar[])
`

type DeletePostsParams struct {
	Ids      []int64 `json:"ids"`
	AuthorID int64   `json:"author_id"`
}

func (q *Queries) DeletePosts(ctx context.Context, arg DeletePostsParams) (int64, error) {
	result, err := q.db.Exec(ctx, deletePosts, arg.Ids, arg.AuthorID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const featurePost = `-- name: FeaturePost :execrows
UPDATE posts SET is_featured = $1::bool
WHERE id = $2::bigint
`

type FeaturePostParams struct {
	IsFeatured bool  `json:"is_featured"`
	ID         int64 `json:"id"`
}

func (q *Queries) FeaturePost(ctx context.Context, arg FeaturePostParams) (int64, error) {
	result, err := q.db.Exec(ctx, featurePost, arg.IsFeatured, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const fetchPosts = `-- name: FetchPosts :many
WITH Data_CTE AS (
  SELECT id, title, author_id, abstract, cover_image,
      view_count, publish_at
  FROM posts
  WHERE status = 'publish'
    AND ($8::bool OR is_featured = $9::bool)
    AND ($10::bool OR author_id = $11::bigint)
    AND ($12::bool OR id = ANY(
      SELECT post_id FROM post_categories
      WHERE category_id = $13::bigint
    ))
    AND ($14::bool OR id = ANY(
      SELECT post_id FROM post_tags
      WHERE tag_id = $15::bigint
    ))
    AND ($16::bool OR title LIKE $17::varchar)
),
Count_CTE AS (
  SELECT count(*) total FROM Data_CTE
),
Tag_CTE AS (
  SELECT pt.post_id post_id,
      array_agg(pt.tag_id)::bigint[] tag_ids,
      array_agg(t.name)::varchar[] tag_names
  FROM post_tags pt
  JOIN tags t ON t.id = pt.tag_id
    AND pt.post_id = ANY(SELECT id FROM Data_CTE)
  GROUP BY pt.post_id
)
SELECT dc.id, dc.title, dc.author_id, dc.abstract, dc.cover_image, dc.view_count, dc.publish_at, cnt.total, u.username, u.info, u.avatar,
    tc.tag_ids, tc.tag_names, fu.follower_id followed,
    (SELECT count(*) FROM follows f
      WHERE f.user_id = dc.author_id) follower_count,
    (SELECT count(*) FROM follows f
      WHERE f.follower_id = dc.author_id) following_count,
    (SELECT count(*) FROM comments cm
      WHERE cm.post_id = dc.id) comment_count,
    (SELECT count(*) FROM post_stars ps
      WHERE ps.post_id = dc.id) star_count
FROM Data_CTE dc
CROSS JOIN Count_CTE cnt
JOIN users u ON u.id = dc.author_id
LEFT JOIN Tag_CTE tc ON tc.post_id = dc.id
LEFT JOIN follows fu
  ON fu.user_id = dc.author_id AND fu.follower_id = $3::bigint
ORDER BY
  CASE WHEN $4::bool THEN view_count END ASC,
  CASE WHEN $5::bool THEN view_count END DESC,
  CASE WHEN $6::bool THEN publish_at END ASC,
  CASE WHEN $7::bool THEN publish_at END DESC
LIMIT $1
OFFSET $2
`

type FetchPostsParams struct {
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
	SelfID        int64  `json:"self_id"`
	ViewCountAsc  bool   `json:"view_count_asc"`
	ViewCountDesc bool   `json:"view_count_desc"`
	PublishAtAsc  bool   `json:"publish_at_asc"`
	PublishAtDesc bool   `json:"publish_at_desc"`
	AnyFeatured   bool   `json:"any_featured"`
	IsFeatured    bool   `json:"is_featured"`
	AnyAuthor     bool   `json:"any_author"`
	AuthorID      int64  `json:"author_id"`
	AnyCategory   bool   `json:"any_category"`
	CategoryID    int64  `json:"category_id"`
	AnyTag        bool   `json:"any_tag"`
	TagID         int64  `json:"tag_id"`
	AnyKeyword    bool   `json:"any_keyword"`
	Keyword       string `json:"keyword"`
}

type FetchPostsRow struct {
	ID             int64         `json:"id"`
	Title          string        `json:"title"`
	AuthorID       int64         `json:"author_id"`
	Abstract       string        `json:"abstract"`
	CoverImage     string        `json:"cover_image"`
	ViewCount      int64         `json:"view_count"`
	PublishAt      time.Time     `json:"publish_at"`
	Total          int64         `json:"total"`
	Username       string        `json:"username"`
	Info           string        `json:"info"`
	Avatar         string        `json:"avatar"`
	TagIds         []int64       `json:"tag_ids"`
	TagNames       []string      `json:"tag_names"`
	Followed       sql.NullInt64 `json:"followed"`
	FollowerCount  int64         `json:"follower_count"`
	FollowingCount int64         `json:"following_count"`
	CommentCount   int64         `json:"comment_count"`
	StarCount      int64         `json:"star_count"`
}

func (q *Queries) FetchPosts(ctx context.Context, arg FetchPostsParams) ([]FetchPostsRow, error) {
	rows, err := q.db.Query(ctx, fetchPosts,
		arg.Limit,
		arg.Offset,
		arg.SelfID,
		arg.ViewCountAsc,
		arg.ViewCountDesc,
		arg.PublishAtAsc,
		arg.PublishAtDesc,
		arg.AnyFeatured,
		arg.IsFeatured,
		arg.AnyAuthor,
		arg.AuthorID,
		arg.AnyCategory,
		arg.CategoryID,
		arg.AnyTag,
		arg.TagID,
		arg.AnyKeyword,
		arg.Keyword,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchPostsRow{}
	for rows.Next() {
		var i FetchPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.AuthorID,
			&i.Abstract,
			&i.CoverImage,
			&i.ViewCount,
			&i.PublishAt,
			&i.Total,
			&i.Username,
			&i.Info,
			&i.Avatar,
			&i.TagIds,
			&i.TagNames,
			&i.Followed,
			&i.FollowerCount,
			&i.FollowingCount,
			&i.CommentCount,
			&i.StarCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPosts = `-- name: GetPosts :many
WITH Data_CTE AS (
  SELECT id, title, author_id, status, is_featured,
      view_count, update_at, publish_at
  FROM posts
  WHERE ($7::bool OR status = $8::varchar)
    AND ($9::bool OR title LIKE $10::varchar)
),
Count_CTE AS (
  SELECT count(*) total FROM Data_CTE
),
Category_CTE AS (
  SELECT pc.post_id post_id,
      array_agg(pc.category_id)::bigint[] category_ids,
      array_agg(c.name)::varchar[] category_names
  FROM post_categories pc
  JOIN categories c ON c.id = pc.category_id
    AND pc.post_id = ANY(SELECT id FROM Data_CTE)
  GROUP BY pc.post_id
)
SELECT dc.id, dc.title, dc.author_id, dc.status, dc.is_featured, dc.view_count, dc.update_at, dc.publish_at, cnt.total, u.username, u.email, u.avatar,
    cc.category_ids, cc.category_names
FROM Data_CTE dc
CROSS JOIN Count_CTE cnt
JOIN users u ON u.id = dc.author_id
LEFT JOIN Category_CTE cc ON cc.post_id = dc.id
ORDER BY
  CASE WHEN $3::bool THEN update_at END ASC,
  CASE WHEN $4::bool THEN update_at END DESC,
  CASE WHEN $5::bool THEN publish_at END ASC,
  CASE WHEN $6::bool THEN publish_at END DESC
LIMIT $1
OFFSET $2
`

type GetPostsParams struct {
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
	UpdateAtAsc   bool   `json:"update_at_asc"`
	UpdateAtDesc  bool   `json:"update_at_desc"`
	PublishAtAsc  bool   `json:"publish_at_asc"`
	PublishAtDesc bool   `json:"publish_at_desc"`
	AnyStatus     bool   `json:"any_status"`
	Status        string `json:"status"`
	AnyKeyword    bool   `json:"any_keyword"`
	Keyword       string `json:"keyword"`
}

type GetPostsRow struct {
	ID            int64     `json:"id"`
	Title         string    `json:"title"`
	AuthorID      int64     `json:"author_id"`
	Status        string    `json:"status"`
	IsFeatured    bool      `json:"is_featured"`
	ViewCount     int64     `json:"view_count"`
	UpdateAt      time.Time `json:"update_at"`
	PublishAt     time.Time `json:"publish_at"`
	Total         int64     `json:"total"`
	Username      string    `json:"username"`
	Email         string    `json:"email"`
	Avatar        string    `json:"avatar"`
	CategoryIds   []int64   `json:"category_ids"`
	CategoryNames []string  `json:"category_names"`
}

func (q *Queries) GetPosts(ctx context.Context, arg GetPostsParams) ([]GetPostsRow, error) {
	rows, err := q.db.Query(ctx, getPosts,
		arg.Limit,
		arg.Offset,
		arg.UpdateAtAsc,
		arg.UpdateAtDesc,
		arg.PublishAtAsc,
		arg.PublishAtDesc,
		arg.AnyStatus,
		arg.Status,
		arg.AnyKeyword,
		arg.Keyword,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostsRow{}
	for rows.Next() {
		var i GetPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.AuthorID,
			&i.Status,
			&i.IsFeatured,
			&i.ViewCount,
			&i.UpdateAt,
			&i.PublishAt,
			&i.Total,
			&i.Username,
			&i.Email,
			&i.Avatar,
			&i.CategoryIds,
			&i.CategoryNames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const increaseViewCount = `-- name: IncreaseViewCount :exec
UPDATE posts SET view_count = view_count + 1
WHERE id = $1 AND status = 'publish'
`

func (q *Queries) IncreaseViewCount(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, increaseViewCount, id)
	return err
}

const listPosts = `-- name: ListPosts :many
WITH Data_CTE AS (
  SELECT id, title, status, view_count, update_at, publish_at
  FROM posts
  WHERE author_id = $7::bigint
    AND ($8::bool OR status = $9::varchar)
    AND ($10::bool OR title LIKE $11::varchar)
),
Count_CTE AS (
  SELECT count(*) total FROM Data_CTE
)
SELECT id, title, status, view_count, update_at, publish_at, total FROM Data_CTE
CROSS JOIN Count_CTE
ORDER BY
  CASE WHEN $3::bool THEN update_at END ASC,
  CASE WHEN $4::bool THEN update_at END DESC,
  CASE WHEN $5::bool THEN publish_at END ASC,
  CASE WHEN $6::bool THEN publish_at END DESC
LIMIT $1
OFFSET $2
`

type ListPostsParams struct {
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
	UpdateAtAsc   bool   `json:"update_at_asc"`
	UpdateAtDesc  bool   `json:"update_at_desc"`
	PublishAtAsc  bool   `json:"publish_at_asc"`
	PublishAtDesc bool   `json:"publish_at_desc"`
	AuthorID      int64  `json:"author_id"`
	AnyStatus     bool   `json:"any_status"`
	Status        string `json:"status"`
	AnyKeyword    bool   `json:"any_keyword"`
	Keyword       string `json:"keyword"`
}

type ListPostsRow struct {
	ID        int64     `json:"id"`
	Title     string    `json:"title"`
	Status    string    `json:"status"`
	ViewCount int64     `json:"view_count"`
	UpdateAt  time.Time `json:"update_at"`
	PublishAt time.Time `json:"publish_at"`
	Total     int64     `json:"total"`
}

func (q *Queries) ListPosts(ctx context.Context, arg ListPostsParams) ([]ListPostsRow, error) {
	rows, err := q.db.Query(ctx, listPosts,
		arg.Limit,
		arg.Offset,
		arg.UpdateAtAsc,
		arg.UpdateAtDesc,
		arg.PublishAtAsc,
		arg.PublishAtDesc,
		arg.AuthorID,
		arg.AnyStatus,
		arg.Status,
		arg.AnyKeyword,
		arg.Keyword,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPostsRow{}
	for rows.Next() {
		var i ListPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Status,
			&i.ViewCount,
			&i.UpdateAt,
			&i.PublishAt,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishPost = `-- name: PublishPost :execrows
UPDATE posts SET status = 'publish'
WHERE id = ANY($1::bigint[]) AND status = 'review'
`

func (q *Queries) PublishPost(ctx context.Context, ids []int64) (int64, error) {
	result, err := q.db.Exec(ctx, publishPost, ids)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const readPost = `-- name: ReadPost :one
WITH Category_CTE AS (
  SELECT post_id,
      array_agg(category_id)::bigint[] category_ids,
      array_agg(name)::varchar[] category_names
  FROM post_categories pc
  JOIN categories c
    ON pc.category_id = c.id AND pc.post_id = $1::bigint
  GROUP BY pc.post_id
),
Tag_CTE AS (
  SELECT post_id,
      array_agg(tag_id)::bigint[] tag_ids,
      array_agg(name)::varchar[] tag_names
  FROM post_tags pt
  JOIN tags t
    ON pt.tag_id = t.id AND pt.post_id = $1::bigint
  GROUP BY pt.post_id
)
SELECT p.id, p.title, p.cover_image, p.content, p.view_count,
    p.publish_at, p.author_id, u.username, u.avatar, u.info,
    cc.category_ids, cc.category_names, tc.tag_ids,
    tc.tag_names, fu.follower_id followed,
    (SELECT count(*) FROM follows f
      WHERE f.user_id = p.author_id) follower_count,
    (SELECT count(*) FROM follows f
      WHERE f.follower_id = p.author_id) following_count,
    (SELECT count(*) FROM post_stars ps
      WHERE ps.post_id = $1::bigint) star_count
FROM posts p JOIN users u ON u.id = p.author_id
LEFT JOIN Category_CTE cc ON cc.post_id = p.id
LEFT JOIN Tag_CTE tc ON tc.post_id = p.id
LEFT JOIN follows fu
  ON fu.user_id = p.author_id AND fu.follower_id = $2::bigint
WHERE p.id = $1::bigint AND p.status = 'publish'
LIMIT 1
`

type ReadPostParams struct {
	PostID int64 `json:"post_id"`
	SelfID int64 `json:"self_id"`
}

type ReadPostRow struct {
	ID             int64         `json:"id"`
	Title          string        `json:"title"`
	CoverImage     string        `json:"cover_image"`
	Content        string        `json:"content"`
	ViewCount      int64         `json:"view_count"`
	PublishAt      time.Time     `json:"publish_at"`
	AuthorID       int64         `json:"author_id"`
	Username       string        `json:"username"`
	Avatar         string        `json:"avatar"`
	Info           string        `json:"info"`
	CategoryIds    []int64       `json:"category_ids"`
	CategoryNames  []string      `json:"category_names"`
	TagIds         []int64       `json:"tag_ids"`
	TagNames       []string      `json:"tag_names"`
	Followed       sql.NullInt64 `json:"followed"`
	FollowerCount  int64         `json:"follower_count"`
	FollowingCount int64         `json:"following_count"`
	StarCount      int64         `json:"star_count"`
}

func (q *Queries) ReadPost(ctx context.Context, arg ReadPostParams) (ReadPostRow, error) {
	row := q.db.QueryRow(ctx, readPost, arg.PostID, arg.SelfID)
	var i ReadPostRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CoverImage,
		&i.Content,
		&i.ViewCount,
		&i.PublishAt,
		&i.AuthorID,
		&i.Username,
		&i.Avatar,
		&i.Info,
		&i.CategoryIds,
		&i.CategoryNames,
		&i.TagIds,
		&i.TagNames,
		&i.Followed,
		&i.FollowerCount,
		&i.FollowingCount,
		&i.StarCount,
	)
	return i, err
}

const reviewPost = `-- name: ReviewPost :one
WITH Category_CTE AS (
  SELECT pc.post_id,
      array_agg(pc.category_id)::bigint[] category_ids,
      array_agg(c.name)::varchar[] category_names
  FROM post_categories pc
  JOIN categories c
    ON pc.category_id = c.id AND pc.post_id = $1::bigint
  GROUP BY pc.post_id
),
Tag_CTE AS (
  SELECT post_id,
      array_agg(tag_id)::bigint[] tag_ids,
      array_agg(name)::varchar[] tag_names
  FROM post_tags pt
  JOIN tags t
    ON pt.tag_id = t.id AND pt.post_id = $1::bigint
  GROUP BY pt.post_id
)
SELECT p.id, title, abstract, cover_image, content, is_featured, status,
    cc.category_ids, cc.category_names, tc.tag_ids, tc.tag_names
FROM posts p
LEFT JOIN Category_CTE cc ON cc.post_id = p.id
LEFT JOIN Tag_CTE tc ON tc.post_id = p.id
WHERE p.id = $1::bigint
  AND ($2::bool OR author_id = $3::bigint)
LIMIT 1
`

type ReviewPostParams struct {
	PostID   int64 `json:"post_id"`
	IsAdmin  bool  `json:"is_admin"`
	AuthorID int64 `json:"author_id"`
}

type ReviewPostRow struct {
	ID            int64    `json:"id"`
	Title         string   `json:"title"`
	Abstract      string   `json:"abstract"`
	CoverImage    string   `json:"cover_image"`
	Content       string   `json:"content"`
	IsFeatured    bool     `json:"is_featured"`
	Status        string   `json:"status"`
	CategoryIds   []int64  `json:"category_ids"`
	CategoryNames []string `json:"category_names"`
	TagIds        []int64  `json:"tag_ids"`
	TagNames      []string `json:"tag_names"`
}

func (q *Queries) ReviewPost(ctx context.Context, arg ReviewPostParams) (ReviewPostRow, error) {
	row := q.db.QueryRow(ctx, reviewPost, arg.PostID, arg.IsAdmin, arg.AuthorID)
	var i ReviewPostRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Abstract,
		&i.CoverImage,
		&i.Content,
		&i.IsFeatured,
		&i.Status,
		&i.CategoryIds,
		&i.CategoryNames,
		&i.TagIds,
		&i.TagNames,
	)
	return i, err
}

const submitPost = `-- name: SubmitPost :execrows
UPDATE posts SET status = 'review'
WHERE id = ANY($1::bigint[]) AND author_id = $2::bigint
  AND status = ANY('{draft, revise}'::varchar[])
`

type SubmitPostParams struct {
	Ids      []int64 `json:"ids"`
	AuthorID int64   `json:"author_id"`
}

func (q *Queries) SubmitPost(ctx context.Context, arg SubmitPostParams) (int64, error) {
	result, err := q.db.Exec(ctx, submitPost, arg.Ids, arg.AuthorID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updatePost = `-- name: UpdatePost :one
UPDATE posts
SET
  title = CASE WHEN $2::bool
    THEN $3::varchar
    ELSE title END,
  abstract = CASE WHEN $4::bool
    THEN $5::varchar
    ELSE abstract END,
  cover_image = CASE WHEN $6::bool
    THEN $7::varchar
    ELSE cover_image END,
  content = CASE WHEN $8::bool
    THEN $9::varchar
    ELSE content END,
  update_at = now()
WHERE id = $1 AND author_id = $10::bigint
  AND status = ANY('{draft, revise}'::varchar[])
RETURNING id, author_id, title, abstract, cover_image, content, status, is_featured, view_count, update_at, publish_at
`

type UpdatePostParams struct {
	ID            int64  `json:"id"`
	SetTitle      bool   `json:"set_title"`
	Title         string `json:"title"`
	SetAbstract   bool   `json:"set_abstract"`
	Abstract      string `json:"abstract"`
	SetCoverImage bool   `json:"set_cover_image"`
	CoverImage    string `json:"cover_image"`
	SetContent    bool   `json:"set_content"`
	Content       string `json:"content"`
	AuthorID      int64  `json:"author_id"`
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, updatePost,
		arg.ID,
		arg.SetTitle,
		arg.Title,
		arg.SetAbstract,
		arg.Abstract,
		arg.SetCoverImage,
		arg.CoverImage,
		arg.SetContent,
		arg.Content,
		arg.AuthorID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.Title,
		&i.Abstract,
		&i.CoverImage,
		&i.Content,
		&i.Status,
		&i.IsFeatured,
		&i.ViewCount,
		&i.UpdateAt,
		&i.PublishAt,
	)
	return i, err
}

const withdrawPost = `-- name: WithdrawPost :execrows
UPDATE posts SET status = 'revise'
WHERE id = ANY($1::bigint[])
  AND status = ANY('{review, publish}'::varchar[])
`

func (q *Queries) WithdrawPost(ctx context.Context, ids []int64) (int64, error) {
	result, err := q.db.Exec(ctx, withdrawPost, ids)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
