// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: follow.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createFollow = `-- name: CreateFollow :exec
INSERT INTO follows (user_id, follower_id)
VALUES ($1, $2)
`

type CreateFollowParams struct {
	UserID     int64 `json:"user_id"`
	FollowerID int64 `json:"follower_id"`
}

func (q *Queries) CreateFollow(ctx context.Context, arg CreateFollowParams) error {
	_, err := q.db.Exec(ctx, createFollow, arg.UserID, arg.FollowerID)
	return err
}

const deleteFollow = `-- name: DeleteFollow :exec
DELETE FROM follows
WHERE user_id = $1 AND follower_id = $2
`

type DeleteFollowParams struct {
	UserID     int64 `json:"user_id"`
	FollowerID int64 `json:"follower_id"`
}

func (q *Queries) DeleteFollow(ctx context.Context, arg DeleteFollowParams) error {
	_, err := q.db.Exec(ctx, deleteFollow, arg.UserID, arg.FollowerID)
	return err
}

const listFollowers = `-- name: ListFollowers :many
WITH Data_CTE AS (
  SELECT user_id, follower_id, create_at FROM follows
  WHERE user_id = $4::bigint
),
Count_CTE AS (
  SELECT count(*) total FROM Data_CTE
)
SELECT dc.follower_id user_id, u.username, u.avatar,
    u.info, cc.total, f.user_id followed
FROM Data_CTE dc
CROSS JOIN Count_CTE cc
JOIN users u ON u.id = dc.follower_id
LEFT JOIN follows f
  ON f.user_id = dc.follower_id AND f.follower_id = $3::bigint
ORDER BY dc.create_at DESC
LIMIT $1 OFFSET $2
`

type ListFollowersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
	SelfID int64 `json:"self_id"`
	UserID int64 `json:"user_id"`
}

type ListFollowersRow struct {
	UserID   int64         `json:"user_id"`
	Username string        `json:"username"`
	Avatar   string        `json:"avatar"`
	Info     string        `json:"info"`
	Total    int64         `json:"total"`
	Followed sql.NullInt64 `json:"followed"`
}

func (q *Queries) ListFollowers(ctx context.Context, arg ListFollowersParams) ([]ListFollowersRow, error) {
	rows, err := q.db.Query(ctx, listFollowers,
		arg.Limit,
		arg.Offset,
		arg.SelfID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFollowersRow{}
	for rows.Next() {
		var i ListFollowersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Avatar,
			&i.Info,
			&i.Total,
			&i.Followed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFollowings = `-- name: ListFollowings :many
WITH Data_CTE AS (
  SELECT user_id, follower_id, create_at FROM follows
  WHERE follower_id = $4::bigint
),
Count_CTE AS (
  SELECT count(*) total FROM Data_CTE
)
SELECT dc.user_id user_id, u.username, u.avatar,
    u.info, cc.total, f.user_id followed
FROM Data_CTE dc
CROSS JOIN Count_CTE cc
JOIN users u ON u.id = dc.user_id
LEFT JOIN follows f
  ON f.user_id = dc.user_id AND f.follower_id = $3::bigint
ORDER BY dc.create_at DESC
LIMIT $1 OFFSET $2
`

type ListFollowingsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
	SelfID int64 `json:"self_id"`
	UserID int64 `json:"user_id"`
}

type ListFollowingsRow struct {
	UserID   int64         `json:"user_id"`
	Username string        `json:"username"`
	Avatar   string        `json:"avatar"`
	Info     string        `json:"info"`
	Total    int64         `json:"total"`
	Followed sql.NullInt64 `json:"followed"`
}

func (q *Queries) ListFollowings(ctx context.Context, arg ListFollowingsParams) ([]ListFollowingsRow, error) {
	rows, err := q.db.Query(ctx, listFollowings,
		arg.Limit,
		arg.Offset,
		arg.SelfID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFollowingsRow{}
	for rows.Next() {
		var i ListFollowingsRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Avatar,
			&i.Info,
			&i.Total,
			&i.Followed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
