// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: post.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one
INSERT INTO posts (author_id, title, abstract, cover_image)
VALUES ($1, $2, $3, $4) RETURNING id, author_id, title, abstract, cover_image, status, featured, view_count, update_at, publish_at
`

type CreatePostParams struct {
	AuthorID   int64  `json:"author_id"`
	Title      string `json:"title"`
	Abstract   string `json:"abstract"`
	CoverImage string `json:"cover_image"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.AuthorID,
		arg.Title,
		arg.Abstract,
		arg.CoverImage,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.Title,
		&i.Abstract,
		&i.CoverImage,
		&i.Status,
		&i.Featured,
		&i.ViewCount,
		&i.UpdateAt,
		&i.PublishAt,
	)
	return i, err
}

const createPostContent = `-- name: CreatePostContent :one
INSERT INTO post_contents (id, content)
VALUES ($1, $2) RETURNING id, content
`

type CreatePostContentParams struct {
	ID      int64  `json:"id"`
	Content string `json:"content"`
}

func (q *Queries) CreatePostContent(ctx context.Context, arg CreatePostContentParams) (PostContent, error) {
	row := q.db.QueryRowContext(ctx, createPostContent, arg.ID, arg.Content)
	var i PostContent
	err := row.Scan(&i.ID, &i.Content)
	return i, err
}

const createPostStar = `-- name: CreatePostStar :exec
INSERT INTO post_stars (post_id, user_id)
VALUES ($1, $2)
`

type CreatePostStarParams struct {
	PostID int64 `json:"post_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) CreatePostStar(ctx context.Context, arg CreatePostStarParams) error {
	_, err := q.db.ExecContext(ctx, createPostStar, arg.PostID, arg.UserID)
	return err
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM posts
WHERE id = $1::bigint AND author_id = $2::bigint
  AND status = ANY('{draft, revise}'::varchar[])
`

type DeletePostParams struct {
	ID       int64 `json:"id"`
	AuthorID int64 `json:"author_id"`
}

func (q *Queries) DeletePost(ctx context.Context, arg DeletePostParams) error {
	_, err := q.db.ExecContext(ctx, deletePost, arg.ID, arg.AuthorID)
	return err
}

const deletePostStar = `-- name: DeletePostStar :exec
DELETE FROM post_stars
WHERE post_id = $1 AND user_id = $2
`

type DeletePostStarParams struct {
	PostID int64 `json:"post_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeletePostStar(ctx context.Context, arg DeletePostStarParams) error {
	_, err := q.db.ExecContext(ctx, deletePostStar, arg.PostID, arg.UserID)
	return err
}

const getPost = `-- name: GetPost :one
WITH Category_CTE AS (
  SELECT pc.post_id,
      array_agg(pc.category_id)::bigint[] category_ids,
      array_agg(c.name)::varchar[] category_names
  FROM post_categories pc
  JOIN categories c
    ON pc.category_id = c.id AND pc.post_id = $1::bigint
  GROUP BY pc.post_id
),
Tag_CTE AS (
  SELECT pt.post_id,
      array_agg(pt.tag_id)::bigint[] tag_ids,
      array_agg(t.name)::varchar[] tag_names
  FROM post_tags pt
  JOIN tags t
    ON pt.tag_id = t.id AND pt.post_id = $1::bigint
  GROUP BY pt.post_id
)
SELECT p.id, p.author_id, p.title, p.abstract, p.cover_image, p.status, p.featured, p.view_count, p.update_at, p.publish_at, pc.content, cc.category_ids, cc.category_names,
    tc.tag_ids, tc.tag_names
FROM posts p
JOIN post_contents pc ON pc.id = p.id
LEFT JOIN Category_CTE cc ON cc.post_id = p.id
LEFT JOIN Tag_CTE tc ON tc.post_id = p.id
WHERE p.id = $1::bigint
  AND ($2::bool OR author_id = $3::bigint)
LIMIT 1
`

type GetPostParams struct {
	PostID   int64 `json:"post_id"`
	IsAdmin  bool  `json:"is_admin"`
	AuthorID int64 `json:"author_id"`
}

type GetPostRow struct {
	ID            int64     `json:"id"`
	AuthorID      int64     `json:"author_id"`
	Title         string    `json:"title"`
	Abstract      string    `json:"abstract"`
	CoverImage    string    `json:"cover_image"`
	Status        string    `json:"status"`
	Featured      bool      `json:"featured"`
	ViewCount     int64     `json:"view_count"`
	UpdateAt      time.Time `json:"update_at"`
	PublishAt     time.Time `json:"publish_at"`
	Content       string    `json:"content"`
	CategoryIds   []int64   `json:"category_ids"`
	CategoryNames []string  `json:"category_names"`
	TagIds        []int64   `json:"tag_ids"`
	TagNames      []string  `json:"tag_names"`
}

func (q *Queries) GetPost(ctx context.Context, arg GetPostParams) (GetPostRow, error) {
	row := q.db.QueryRowContext(ctx, getPost, arg.PostID, arg.IsAdmin, arg.AuthorID)
	var i GetPostRow
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.Title,
		&i.Abstract,
		&i.CoverImage,
		&i.Status,
		&i.Featured,
		&i.ViewCount,
		&i.UpdateAt,
		&i.PublishAt,
		&i.Content,
		pq.Array(&i.CategoryIds),
		pq.Array(&i.CategoryNames),
		pq.Array(&i.TagIds),
		pq.Array(&i.TagNames),
	)
	return i, err
}

const getPosts = `-- name: GetPosts :many
WITH Data_CTE AS (
  SELECT id, author_id, title, abstract, cover_image, status, featured, view_count, update_at, publish_at FROM posts
  WHERE status = 'publish'
    AND ($4::bool OR featured = $5::bool)
    AND ($6::bool OR author_id = $7::bigint)
    AND ($8::bool OR id = ANY(
      SELECT post_id FROM post_categories
      WHERE category_id = $9::bigint
    ))
    AND ($10::bool OR id = ANY(
      SELECT post_id FROM post_tags
      WHERE tag_id = $11::bigint
    ))
    AND ($12::bool OR title LIKE $13::varchar)
),
Count_CTE AS (
  SELECT count(*) total FROM Data_CTE
),
Post_CTE AS (
  SELECT id, author_id, title, abstract, cover_image, status, featured, view_count, update_at, publish_at FROM Data_CTE
  ORDER BY
    CASE WHEN $14::bool THEN publish_at END ASC,
    CASE WHEN $15::bool THEN publish_at END DESC,
    CASE WHEN $16::bool THEN view_count END ASC,
    CASE WHEN $17::bool THEN view_count END DESC,
    id ASC
  LIMIT $1
  OFFSET $2
),
Tag_CTE AS (
  SELECT pt.post_id,
      array_agg(t.id)::bigint[] tag_ids,
      array_agg(t.name)::varchar[] tag_names
  FROM post_tags pt
  JOIN tags t
    ON pt.tag_id = t.id
    AND pt.post_id = ANY(SELECT id FROM Post_CTE)
  GROUP BY pt.post_id
)
SELECT p.id, p.author_id, p.title, p.abstract, p.cover_image, p.status, p.featured, p.view_count, p.update_at, p.publish_at, cnt.total, u.username, u.intro, u.avatar,
    tc.tag_ids, tc.tag_names, fu.follower_id followed,
    (SELECT count(*) FROM follows f
      WHERE f.user_id = p.author_id) follower_count,
    (SELECT count(*) FROM follows f
      WHERE f.follower_id = p.author_id) following_count,
    (SELECT count(*) FROM comments cm
      WHERE cm.post_id = p.id) comment_count,
    (SELECT count(*) FROM post_stars ps
      WHERE ps.post_id = p.id) star_count
FROM Post_CTE p
CROSS JOIN Count_CTE cnt
JOIN users u ON u.id = p.author_id
LEFT JOIN Tag_CTE tc ON tc.post_id = p.id
LEFT JOIN follows fu
  ON fu.user_id = p.author_id AND fu.follower_id = $3::bigint
`

type GetPostsParams struct {
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
	SelfID        int64  `json:"self_id"`
	AnyFeatured   bool   `json:"any_featured"`
	Featured      bool   `json:"featured"`
	AnyAuthor     bool   `json:"any_author"`
	AuthorID      int64  `json:"author_id"`
	AnyCategory   bool   `json:"any_category"`
	CategoryID    int64  `json:"category_id"`
	AnyTag        bool   `json:"any_tag"`
	TagID         int64  `json:"tag_id"`
	AnyKeyword    bool   `json:"any_keyword"`
	Keyword       string `json:"keyword"`
	PublishAtAsc  bool   `json:"publish_at_asc"`
	PublishAtDesc bool   `json:"publish_at_desc"`
	ViewCountAsc  bool   `json:"view_count_asc"`
	ViewCountDesc bool   `json:"view_count_desc"`
}

type GetPostsRow struct {
	ID             int64         `json:"id"`
	AuthorID       int64         `json:"author_id"`
	Title          string        `json:"title"`
	Abstract       string        `json:"abstract"`
	CoverImage     string        `json:"cover_image"`
	Status         string        `json:"status"`
	Featured       bool          `json:"featured"`
	ViewCount      int64         `json:"view_count"`
	UpdateAt       time.Time     `json:"update_at"`
	PublishAt      time.Time     `json:"publish_at"`
	Total          int64         `json:"total"`
	Username       string        `json:"username"`
	Intro          string        `json:"intro"`
	Avatar         string        `json:"avatar"`
	TagIds         []int64       `json:"tag_ids"`
	TagNames       []string      `json:"tag_names"`
	Followed       sql.NullInt64 `json:"followed"`
	FollowerCount  int64         `json:"follower_count"`
	FollowingCount int64         `json:"following_count"`
	CommentCount   int64         `json:"comment_count"`
	StarCount      int64         `json:"star_count"`
}

func (q *Queries) GetPosts(ctx context.Context, arg GetPostsParams) ([]GetPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPosts,
		arg.Limit,
		arg.Offset,
		arg.SelfID,
		arg.AnyFeatured,
		arg.Featured,
		arg.AnyAuthor,
		arg.AuthorID,
		arg.AnyCategory,
		arg.CategoryID,
		arg.AnyTag,
		arg.TagID,
		arg.AnyKeyword,
		arg.Keyword,
		arg.PublishAtAsc,
		arg.PublishAtDesc,
		arg.ViewCountAsc,
		arg.ViewCountDesc,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostsRow{}
	for rows.Next() {
		var i GetPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.Title,
			&i.Abstract,
			&i.CoverImage,
			&i.Status,
			&i.Featured,
			&i.ViewCount,
			&i.UpdateAt,
			&i.PublishAt,
			&i.Total,
			&i.Username,
			&i.Intro,
			&i.Avatar,
			pq.Array(&i.TagIds),
			pq.Array(&i.TagNames),
			&i.Followed,
			&i.FollowerCount,
			&i.FollowingCount,
			&i.CommentCount,
			&i.StarCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPosts = `-- name: ListPosts :many
WITH Data_CTE AS (
  SELECT id, author_id, title, abstract, cover_image, status, featured, view_count, update_at, publish_at FROM posts
  WHERE ($3::bool OR author_id = $4::bigint)
    AND ($5::bool OR status = $6::varchar)
    AND ($7::bool OR title LIKE $8::varchar)
),
Count_CTE AS (
  SELECT count(*) total FROM Data_CTE
),
Post_CTE AS (
  SELECT id, author_id, title, abstract, cover_image, status, featured, view_count, update_at, publish_at FROM Data_CTE
  ORDER BY
    CASE WHEN $9::bool THEN update_at END ASC,
    CASE WHEN $10::bool THEN update_at END DESC,
    CASE WHEN $11::bool THEN publish_at END ASC,
    CASE WHEN $12::bool THEN publish_at END DESC,
    CASE WHEN $13::bool THEN view_count END ASC,
    CASE WHEN $14::bool THEN view_count END DESC,
    id ASC
  LIMIT $1
  OFFSET $2
),
Category_CTE AS (
  SELECT pc.post_id,
      array_agg(c.id)::bigint[] category_ids,
      array_agg(c.name)::varchar[] category_names
  FROM post_categories pc
  JOIN categories c
    ON pc.category_id = c.id
    AND pc.post_id = ANY(SELECT id FROM Post_CTE)
  GROUP BY pc.post_id
),
Tag_CTE AS (
  SELECT pt.post_id,
      array_agg(t.id)::bigint[] tag_ids,
      array_agg(t.name)::varchar[] tag_names
  FROM post_tags pt
  JOIN tags t
    ON pt.tag_id = t.id
    AND pt.post_id = ANY(SELECT id FROM Post_CTE)
  GROUP BY pt.post_id
)
SELECT p.id, p.author_id, p.title, p.abstract, p.cover_image, p.status, p.featured, p.view_count, p.update_at, p.publish_at, cnt.total, u.username, u.email, u.avatar,
      cc.category_ids, cc.category_names,
      tc.tag_ids, tc.tag_names
FROM Post_CTE p
CROSS JOIN Count_CTE cnt
JOIN users u ON u.id = p.author_id
LEFT JOIN Category_CTE cc ON cc.post_id = p.id
LEFT JOIN Tag_CTE tc ON tc.post_id = p.id
`

type ListPostsParams struct {
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
	IsAdmin       bool   `json:"is_admin"`
	AuthorID      int64  `json:"author_id"`
	AnyStatus     bool   `json:"any_status"`
	Status        string `json:"status"`
	AnyKeyword    bool   `json:"any_keyword"`
	Keyword       string `json:"keyword"`
	UpdateAtAsc   bool   `json:"update_at_asc"`
	UpdateAtDesc  bool   `json:"update_at_desc"`
	PublishAtAsc  bool   `json:"publish_at_asc"`
	PublishAtDesc bool   `json:"publish_at_desc"`
	ViewCountAsc  bool   `json:"view_count_asc"`
	ViewCountDesc bool   `json:"view_count_desc"`
}

type ListPostsRow struct {
	ID            int64     `json:"id"`
	AuthorID      int64     `json:"author_id"`
	Title         string    `json:"title"`
	Abstract      string    `json:"abstract"`
	CoverImage    string    `json:"cover_image"`
	Status        string    `json:"status"`
	Featured      bool      `json:"featured"`
	ViewCount     int64     `json:"view_count"`
	UpdateAt      time.Time `json:"update_at"`
	PublishAt     time.Time `json:"publish_at"`
	Total         int64     `json:"total"`
	Username      string    `json:"username"`
	Email         string    `json:"email"`
	Avatar        string    `json:"avatar"`
	CategoryIds   []int64   `json:"category_ids"`
	CategoryNames []string  `json:"category_names"`
	TagIds        []int64   `json:"tag_ids"`
	TagNames      []string  `json:"tag_names"`
}

func (q *Queries) ListPosts(ctx context.Context, arg ListPostsParams) ([]ListPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPosts,
		arg.Limit,
		arg.Offset,
		arg.IsAdmin,
		arg.AuthorID,
		arg.AnyStatus,
		arg.Status,
		arg.AnyKeyword,
		arg.Keyword,
		arg.UpdateAtAsc,
		arg.UpdateAtDesc,
		arg.PublishAtAsc,
		arg.PublishAtDesc,
		arg.ViewCountAsc,
		arg.ViewCountDesc,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPostsRow{}
	for rows.Next() {
		var i ListPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.Title,
			&i.Abstract,
			&i.CoverImage,
			&i.Status,
			&i.Featured,
			&i.ViewCount,
			&i.UpdateAt,
			&i.PublishAt,
			&i.Total,
			&i.Username,
			&i.Email,
			&i.Avatar,
			pq.Array(&i.CategoryIds),
			pq.Array(&i.CategoryNames),
			pq.Array(&i.TagIds),
			pq.Array(&i.TagNames),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readPost = `-- name: ReadPost :one
WITH Post_CTE AS (
  UPDATE posts SET view_count = view_count + 1
  WHERE id = $1::bigint AND status = 'publish'
  RETURNING id, author_id, title, abstract, cover_image, status, featured, view_count, update_at, publish_at
),
Category_CTE AS (
  SELECT pc.post_id,
      array_agg(c.id)::bigint[] category_ids,
      array_agg(c.name)::varchar[] category_names
  FROM post_categories pc
  JOIN categories c
    ON pc.category_id = c.id AND pc.post_id = $1::bigint
  GROUP BY pc.post_id
),
Tag_CTE AS (
  SELECT pt.post_id,
      array_agg(t.id)::bigint[] tag_ids,
      array_agg(t.name)::varchar[] tag_names
  FROM post_tags pt
  JOIN tags t
    ON pt.tag_id = t.id AND pt.post_id = $1::bigint
  GROUP BY pt.post_id
)
SELECT p.id, p.title, pc.content, p.view_count, p.publish_at,
    p.author_id, u.username, u.avatar, u.intro,
    cc.category_ids, cc.category_names, tc.tag_ids,
    tc.tag_names, fu.follower_id followed,
    (SELECT count(*) FROM follows f
      WHERE f.user_id = p.author_id) follower_count,
    (SELECT count(*) FROM follows f
      WHERE f.follower_id = p.author_id) following_count,
    (SELECT count(*) FROM post_stars ps
      WHERE ps.post_id = $1::bigint) star_count
FROM Post_CTE p
JOIN post_contents pc ON pc.id = p.id
JOIN users u ON u.id = p.author_id
LEFT JOIN Category_CTE cc ON cc.post_id = p.id
LEFT JOIN Tag_CTE tc ON tc.post_id = p.id
LEFT JOIN follows fu
  ON fu.user_id = p.author_id AND fu.follower_id = $2::bigint
`

type ReadPostParams struct {
	PostID int64 `json:"post_id"`
	SelfID int64 `json:"self_id"`
}

type ReadPostRow struct {
	ID             int64         `json:"id"`
	Title          string        `json:"title"`
	Content        string        `json:"content"`
	ViewCount      int64         `json:"view_count"`
	PublishAt      time.Time     `json:"publish_at"`
	AuthorID       int64         `json:"author_id"`
	Username       string        `json:"username"`
	Avatar         string        `json:"avatar"`
	Intro          string        `json:"intro"`
	CategoryIds    []int64       `json:"category_ids"`
	CategoryNames  []string      `json:"category_names"`
	TagIds         []int64       `json:"tag_ids"`
	TagNames       []string      `json:"tag_names"`
	Followed       sql.NullInt64 `json:"followed"`
	FollowerCount  int64         `json:"follower_count"`
	FollowingCount int64         `json:"following_count"`
	StarCount      int64         `json:"star_count"`
}

func (q *Queries) ReadPost(ctx context.Context, arg ReadPostParams) (ReadPostRow, error) {
	row := q.db.QueryRowContext(ctx, readPost, arg.PostID, arg.SelfID)
	var i ReadPostRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.ViewCount,
		&i.PublishAt,
		&i.AuthorID,
		&i.Username,
		&i.Avatar,
		&i.Intro,
		pq.Array(&i.CategoryIds),
		pq.Array(&i.CategoryNames),
		pq.Array(&i.TagIds),
		pq.Array(&i.TagNames),
		&i.Followed,
		&i.FollowerCount,
		&i.FollowingCount,
		&i.StarCount,
	)
	return i, err
}

const updatePost = `-- name: UpdatePost :one
UPDATE posts
SET
  title = coalesce($2, title),
  abstract = coalesce($3, abstract),
  cover_image = coalesce($4, cover_image),
  update_at = now()
WHERE id = $1 AND author_id = $5::bigint
  AND status = ANY('{draft, revise}'::varchar[])
RETURNING id, author_id, title, abstract, cover_image, status, featured, view_count, update_at, publish_at
`

type UpdatePostParams struct {
	ID         int64          `json:"id"`
	Title      sql.NullString `json:"title"`
	Abstract   sql.NullString `json:"abstract"`
	CoverImage sql.NullString `json:"cover_image"`
	AuthorID   int64          `json:"author_id"`
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Abstract,
		arg.CoverImage,
		arg.AuthorID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.Title,
		&i.Abstract,
		&i.CoverImage,
		&i.Status,
		&i.Featured,
		&i.ViewCount,
		&i.UpdateAt,
		&i.PublishAt,
	)
	return i, err
}

const updatePostContent = `-- name: UpdatePostContent :one
UPDATE post_contents
SET content = $2
WHERE id = (
  SELECT p.id FROM posts p
  WHERE p.id = $1
    AND author_id = $3::bigint
    AND status = ANY('{draft, revise}'::varchar[])
) RETURNING id, content
`

type UpdatePostContentParams struct {
	ID       int64  `json:"id"`
	Content  string `json:"content"`
	AuthorID int64  `json:"author_id"`
}

func (q *Queries) UpdatePostContent(ctx context.Context, arg UpdatePostContentParams) (PostContent, error) {
	row := q.db.QueryRowContext(ctx, updatePostContent, arg.ID, arg.Content, arg.AuthorID)
	var i PostContent
	err := row.Scan(&i.ID, &i.Content)
	return i, err
}

const updatePostFeature = `-- name: UpdatePostFeature :exec
UPDATE posts SET featured = $1::bool
WHERE id = $2::bigint
`

type UpdatePostFeatureParams struct {
	Featured bool  `json:"featured"`
	ID       int64 `json:"id"`
}

func (q *Queries) UpdatePostFeature(ctx context.Context, arg UpdatePostFeatureParams) error {
	_, err := q.db.ExecContext(ctx, updatePostFeature, arg.Featured, arg.ID)
	return err
}

const updatePostStatus = `-- name: UpdatePostStatus :many
UPDATE posts SET status = $1::varchar
WHERE id = ANY($2::bigint[]) AND status = ANY($3::varchar[])
  AND ($4::bool OR author_id = $5::bigint)
RETURNING id, author_id, title, abstract, cover_image, status, featured, view_count, update_at, publish_at
`

type UpdatePostStatusParams struct {
	Status    string   `json:"status"`
	Ids       []int64  `json:"ids"`
	OldStatus []string `json:"old_status"`
	IsAdmin   bool     `json:"is_admin"`
	AuthorID  int64    `json:"author_id"`
}

func (q *Queries) UpdatePostStatus(ctx context.Context, arg UpdatePostStatusParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, updatePostStatus,
		arg.Status,
		pq.Array(arg.Ids),
		pq.Array(arg.OldStatus),
		arg.IsAdmin,
		arg.AuthorID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Post{}
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.Title,
			&i.Abstract,
			&i.CoverImage,
			&i.Status,
			&i.Featured,
			&i.ViewCount,
			&i.UpdateAt,
			&i.PublishAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
